#+TITLE: Subbehaviors
#+AUTHOR: Jay Kamat, Josh Ting, Jason Chan
#+EMAIL: jaygkamat@gmail.com, joshting25@gmail.com, jason27chan@gmail.com
#+REVEAL_THEME: black
#+REVEAL_TRANS: linear
#+REVEAL_SPEED: fast
#+REVEAL_PLUGINS: (notes pdf)
#+REVEAL_HLEVEL: 1
#+OPTIONS: toc:nil timestamp:nil reveal_control:t num:nil reveal_history:t tags:nil author:nil

# Export section for md
* Subbehaviors {#t20183}                                 :docs:
* Questions about Plays?
- Topics Covered:
  - Python
  - Play/Tactic/Skill Structure
- Last meeting was pretty dense
  - RoboCup is complicated
  - If you got it, great
  - If you didn't, great
    - Please ask questions when you don't understand something because we can guarantee someone else has the same question. 
- And today, we're going into...
** Additional Information                                             :docs:
- See the previous slide deck and docs for more information, they should be a pretty comprehensive overview of our play system.

* State Machines

** What are they?
- A state machine is a series of states
- You can transition between them
- A state can transition to multiple other states
- A state transition only occurs if a condition is fulfilled
*** Examples                                                         :docs:
- A washing machine is a state machine, going between different states to cycle between wash, dry, etc.
- School are state machines, where you transition to different classes at certain times. 
- [[https://en.wikipedia.org/wiki/Finite-state_machine][Wikipedia Page on State Machines]]

** Elevator
[[file:https://i.imgur.com/KPv5sSk.png]]

** Robocup Statemachines
- Skills, tactics, and plays all have internal states.
- We define those states using enums.
  - default to start, running, complete
- Each state has an on_enter, execute, and on_exit.
  - on_enter and on_exit are run once at the beginning and end of the state respectively
  - execute is run repetitively while we are in a state 

** Defining States in code layout
#+BEGIN_SRC python
  # First create a state Enum (An enum is just a group of names)
  class OurState(enum.Enum):
      start = 0
      processing = 1
      terminated = 2

  # Then, register your states in our state machine class
  # You must be in a play/tactic/skill for this to work
  self.add_state(PlayName.OurState.start,
                 # This is the superclass of our state. Most of the time,
                 # this is 'running' (see below)
                 behavior.Behavior.State.start)

  self.add_state(PlayName.OurState.processing,
                 behavior.Behavior.State.running)

  self.add_state(PlayName.OurState.terminated,
                 behavior.Behavior.State.completed)
#+END_SRC

** Defining States in code example
#+BEGIN_SRC python
  # This code is from our current iteration of capture.

  # First create a state Enum (An enum is just a group of names)
  class State(Enum):
    course_approach = 1
    fine_approach = 2
    delay = 3

  # Then, register your states in our state machine class
  # You must be in a play/tactic/skill for this to work
  self.add_state(Capture.State.course_approach,
                 behavior.Behavior.State.running)
  self.add_state(Capture.State.fine_approach,
                 behavior.Behavior.State.running)
  self.add_state(Capture.State.delay,
                 behavior.Behavior.State.running)
#+END_SRC


** Defining Transitions Layout
#+BEGIN_SRC python
  self.add_transition(
      Capture.State.course_approach,
      Capture.State.fine_approach, lambda: (self.bot_in_front_of_ball(
      ) or self.bot_near_ball(Capture.CourseApproachDist)) and main.ball(
      ).valid, 'dist to ball < threshold')

  self.add_transition(
      Capture.State.fine_approach,
      Capture.State.delay, lambda: evaluation.ball.robot_has_ball(self.robot), 
      'has ball')

  self.add_transition(
      Capture.State.delay, 
      behavior.Behavior.State.completed, 
      lambda: time.time() - self.start_time > Capture.DelayTime and 
      evaluation.ball.robot_has_ball(self.robot),
      'delay before finish')
#+END_SRC

* The lecture hall state machine
- Let's say your lecture hall is a state 

** What would determine whether we transition into our lecture hall state?
- 

** When would we take out our notes?
- on_enter
- execute
- on_exit

** When would we take notes?
- on_enter
- execute
- on_exit

** When would we pack up?
- on_enter
- execute
- on_exit

** Where would we take out our phone?
- on_enter
- execute
- on_exit

** Additional Information on State Machines                           :docs:
- While you /do not/ need to know advanced state machine ideas, you need to be comfortable working with and parsing existing state machines from a diagram or from our code.
- [[https://en.wikipedia.org/wiki/Finite-state_machine][Wikipedia Article]]
- [[http://blog.markshead.com/869/state-machines-computer-science/][A quick block post about state machines]]
- [[https://engineering.shopify.com/17488160-why-developers-should-be-force-fed-state-machines][You might be using state machines in a hacky way already...]]
- [[https://github.com/RoboJackets/robocup-software/blob/master/soccer/gameplay/fsm.py][Our Current State Machine Implementation]]

* Subbehaviors!
- A behavior is a generic name for any skill, play, or tactic.
- Last meeting we learned about Plays/Tactics/Skills
  - How do we put them together?
- Subbehaviors allow you to reuse our behaviors in many plays.
  - Example: We have /one/ move play, used by kicker tactics, passing tactics, goalie, etc.
** Examples of Subbehaviors
- Offense Play contains Passing Tactics, and Move Skills
- Passing Tactic Contains Move and Kick Skills
** /Behavior/ Tree!
#+BEGIN_SRC text
Basic122::running
    Mark::running[robot=4]
        move(0.767296, 6.51286)
        endVelocity(0, 0)
        face(0.160718, 9.15305)
    PivotKick::capturing
        Capture::course_approach[robot=2]
            face(0.160718, 9.15305)
            avoidBall(-1)
            move(0.176939, 9.114)
            endVelocity(0, 0)
    Mark::running[robot=1]
        move(-0.829012, 6.03814)
        endVelocity(0, 0)
        face(0.160718, 9.15305)
#+END_SRC

*** Details                                                          :docs:
- Here we have a tree of all the behaviors running
- We have a basic122 play running
- It is running 2 Marks, and a PivotKick in this frame
- The marks are directly running robot commands, like move, and face.
- The PivotKick is running a capture skill, which is running robot commands, like face, move, etc.
** /Behavior/ Tree! (cont.)
#+BEGIN_SRC text
Basic122::running
    Defense::defending
        SubmissiveDefender::marking
            Move::completed[robot=5]
                face(0.160718, 9.15305)
        SubmissiveDefender::marking
            Move::completed[robot=3]
                face(0.160718, 9.15305)
        SubmissiveGoalie::block
            Move::running[robot=0]
                face(0.160718, 9.15305)
                move(0.290916, 0.14)
                endVelocity(0, 0)
#+END_SRC

*** Details                                                          :docs:
- Pretty much same thing here
- We've got a Defense tactic running, with SubmissiveDefender and Goalie Skills
- These skills actually run robot commands.
* How do I use subbehaviors?
** Adding Subbehaviors
#+BEGIN_SRC python
  self.add_subbehavior(skill_object,
                       "Name of Subbehavior",
                       required=False or True
                       priority=10) # A higher number is higher priority
#+END_SRC
- If adding a ~complex behavior~ or ~single robot complex behavior~, don't pass in values for ~required~ or ~priority~

*** Details                                                          :docs:
- For more docs on this entire section see [[https://robojackets.github.io/robocup-software/classgameplay_1_1single__robot__composite__behavior_1_1_single_robot_composite_behavior.html][this link.]]
- These subbehaviors show up in the behavior tree when you run your program.
- This can be extremely useful when debugging state transitions or subbehavior assignments.
** Removing Subbehaviors
#+BEGIN_SRC python
self.remove_subbehavior('string name')

self.remove_all_subbehaviors()
#+END_SRC
** Getting Subbehavior Plays
#+BEGIN_SRC python
a_subbheavior = self.subbehavior_with_name('string name')
#+END_SRC
* Real Examples
** CoordinatedPass Tactic
#+BEGIN_SRC python
  def on_enter_running(self):
      receiver = skills.pass_receive.PassReceive()
      receiver.receive_point = self.receive_point
      self.add_subbehavior(receiver,
                           'receiver',
                           required=self.receiver_required)

  def on_exit_running(self):
      self.remove_subbehavior('receiver')
#+END_SRC
** Line Up Tactic
- First State Machine is set up, then:
#+BEGIN_SRC python
  # Triggered whenever the line changes
  self.remove_all_subbehaviors()
  for i in range(6):
      pt = self._line.get_pt(0) + (self.diff * float(i))
      self.add_subbehavior(
          skills.move.Move(pt),
          name="robot" + str(i),
          required=False,
          priority=6 - i)
#+END_SRC

#+BEGIN_SRC python
  def execute_running(self):
      for i in range(6):
          pt = self._line.get_pt(0) + (self.diff * float(i))
          self.subbehavior_with_name("robot" + str(i)).pos = pt
#+END_SRC
* RoboCup Pro Tip
- Find some code doing something like what you want
- Tweak it until it works
- It's less effective than working everything out, but it's great for beginners!

* Assignment
- Create a Triangle Pass Play
- Move 3 Robots into a triangle formation, and pass between them.
- Starter code is in ~soccer/gameplay/plays/skel/triangle_pass.py~ (same as last time).
- Move it to ~soccer/gameplay/plays/testing/triangle_pass.py~ to begin.
** Tips
1. Use Move Skills to move your robots to the triangle initially
2. Use the CoordinatedPass Tactic to pass between, setting receive points as sides of the triangle
3. At a bare minimum, I would make setup and passing states. You may want to have a state for every side of the triangle (or not).
