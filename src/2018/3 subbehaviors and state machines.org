#+TITLE: Subbehaviors
#+AUTHOR: Jay Kamat, Josh Ting, Jason Chan
#+EMAIL: jaygkamat@gmail.com, joshting25@gmail.com, jason27chan@gmail.com
#+REVEAL_THEME: black
#+REVEAL_TRANS: linear
#+REVEAL_SPEED: fast
#+REVEAL_PLUGINS: (notes pdf)
#+REVEAL_HLEVEL: 1
#+OPTIONS: toc:nil timestamp:nil reveal_control:t num:nil reveal_history:t tags:nil author:nil

# Export section for md
* Subbehaviors {#t20183}                                 :docs:
* Questions about Plays?
- Topics Covered:
  - Python
  - Play/Tactic/Skill Structure
- Last meeting was pretty dense
  - RoboCup is complicated
  - If you got it, great
  - If you didn't, great
    - Please ask questions when you don't understand something because we can guarantee someone else has the same question. 
- And today, we're going into...
** Additional Information                                             :docs:
- See the previous slide deck and docs for more information, they should be a pretty comprehensive overview of our play system.

* State Machines

** What are they?
- A state machine is a series of states
- You can transition between them
- A state can transition to multiple other states
- A state transition only occurs if a condition is fulfilled
*** Examples                                                         :docs:
- A washing machine is a state machine, going between different states to cycle between wash, dry, etc based on time.
- School are state machines, where you transition to different classes at certain times. 
- [[https://en.wikipedia.org/wiki/Finite-state_machine][Wikipedia Page on State Machines]]

** Elevator
[[file:https://i.imgur.com/KPv5sSk.png]]

** Robocup Statemachines
- Skills, tactics, and plays all have internal states.
- We define those states using enums.
  - Behaviors has some default states that we can use called start, running, complete
- Each state has an on_enter, execute, and on_exit.
  - on_enter and on_exit are run once at the beginning and end of the state respectively
  - execute is run repetitively while we are in a state 

* How do we implement state machines in our code?

** Implementing State Machines
- In our code, we have three distinct parts in implementing state machines
    - Defining States
    - Defining Transitions
    - Defining state actions
        - Specifically, what we do upon entering a state, while a state is running, and upon exiting a state
- We have a play called WhichHalf, which prints information about the ball based on whether it is in the top half or in the bottom half of the field
** Defining States 
#+BEGIN_SRC python
  # First create a state Enum (An enum is just a group of names)
  # Define your states here.
        # eg: some_state = 0
        # -----------------------
        tophalf = 0
        bottomhalf = 1

  # Register the states you defined using 'add_state'.
  # eg: self.add_state(WhichHalf.State.<???>,
  #                    behavior.Behavior.State.running)
  # ----------------------------------------------------

  # You must be in a play/tactic/skill for this to work
  self.add_state(WhichHalf.State.tophalf,
                behavior.Behavior.State.running)
  self.add_state(WhichHalf.State.bottomhalf,
                behavior.Behavior.State.running)
#+END_SRC

** Defining State Transitions 
#+BEGIN_SRC python
  # Add your state transitions using 'add_transition'.
  # eg: self.add_transition(behavior.Behavior.State.start,
  #                         self.State.<???>, lambda: True,
  #                         'immediately')
  # eg: self.add_transition(self.State.<???>, self.State.<???>,
  #                         lambda: <???>,
  #                         'state change message')
  # ------------------------------------------------------------
  self.add_transition(behavior.Behavior.State.start,
                    self.State.bottomhalf, lambda: True, 'immediately')

  self.add_transition(self.State.bottomhalf,
                    self.State.tophalf, lambda: not in_bottom_half(),
                    'detected top half')

  self.add_transition(self.State.tophalf, self.State.bottomhalf,
                    in_bottom_half, 'detected bottom half')

#+END_SRC

** Defining State Actions
#+BEGIN_SRC
    # Define your own 'on_enter' and 'execute' functions here.
    # eg: def on_enter_<???>(self):
    #         print('Something?')
    # eg: def execute_<???>(self):
    #         print('Something?')
    # eg: def on_exit_<???>(self):
    #         print('Soemthing?')
    # ---------------------------------------------------------

    def on_enter_tophalf(self):
        print('Ball entered top half')

    def on_enter_bottomhalf(self):
        print('Ball entered bottom half')    

    def execute_tophalf(self):
        print('Ball in top half')

    def execute_bottomhalf(self):
        print('Ball in bottom half')

    def on_exit_bottomhalf(self):
        print('Ball exited bottom half')

    def on_exit_tophalf(self):
        print('Ball exited top half')
#+END_SRC

* The lecture hall state machine
- Let's say your lecture hall is a state 

** What would determine whether we transition into our lecture hall state?

** When would we take out our notes?
- on_enter
- execute
- on_exit

** When would we take notes?
- on_enter
- execute
- on_exit

** When would we pack up?
- on_enter
- execute
- on_exit

** Where would we take out our phone?
- on_enter
- execute
- on_exit

** Additional Information on State Machines                           :docs:
- While you /do not/ need to know advanced state machine ideas, you need to be comfortable working with and parsing existing state machines from a diagram or from our code.
- [[https://en.wikipedia.org/wiki/Finite-state_machine][Wikipedia Article]]
- [[http://blog.markshead.com/869/state-machines-computer-science/][A quick block post about state machines]]
- [[https://engineering.shopify.com/17488160-why-developers-should-be-force-fed-state-machines][You might be using state machines in a hacky way already...]]
- [[https://github.com/RoboJackets/robocup-software/blob/master/soccer/gameplay/fsm.py][Our Current State Machine Implementation]]

* Subbehaviors!
- A behavior is a generic name for any skill, play, or tactic.
- Last meeting we learned about Plays/Tactics/Skills
  - How do we put them together?
- Subbehaviors allow you to reuse our behaviors in many plays.
  - Example: We have /one/ move play, used by kicker tactics, passing tactics, goalie, etc.
** Examples of Subbehaviors
- Offense Play contains Passing Tactics, and Move Skills
- Passing Tactic Contains Move and Kick Skills
** /Behavior/ Tree!
#+BEGIN_SRC text
Basic122::running
    Mark::running[robot=4]
        move(0.767296, 6.51286)
        endVelocity(0, 0)
        face(0.160718, 9.15305)
    PivotKick::capturing
        Capture::course_approach[robot=2]
            face(0.160718, 9.15305)
            avoidBall(-1)
            move(0.176939, 9.114)
            endVelocity(0, 0)
    Mark::running[robot=1]
        move(-0.829012, 6.03814)
        endVelocity(0, 0)
        face(0.160718, 9.15305)
#+END_SRC

*** Details                                                          :docs:
- Here we have a tree of all the behaviors running
- We have a basic122 play running
- It is running 2 Marks, and a PivotKick in this frame
- The marks are directly running robot commands, like move, and face.
- The PivotKick is running a capture skill, which is running robot commands, like face, move, etc.
** /Behavior/ Tree! (cont.)
#+BEGIN_SRC text
Basic122::running
    Defense::defending
        SubmissiveDefender::marking
            Move::completed[robot=5]
                face(0.160718, 9.15305)
        SubmissiveDefender::marking
            Move::completed[robot=3]
                face(0.160718, 9.15305)
        SubmissiveGoalie::block
            Move::running[robot=0]
                face(0.160718, 9.15305)
                move(0.290916, 0.14)
                endVelocity(0, 0)
#+END_SRC

*** Details                                                          :docs:
- Pretty much same thing here
- We've got a Defense tactic running, with SubmissiveDefender and Goalie Skills
- These skills actually run robot commands.
* How do I use subbehaviors?
** Adding Subbehaviors
#+BEGIN_SRC python
  self.add_subbehavior(skill_object,
                       "Name of Subbehavior",
                       required=False or True
                       priority=10) # A higher number is higher priority
#+END_SRC
- If adding a ~complex behavior~ or ~single robot complex behavior~, don't pass in values for ~required~ or ~priority~

*** Details                                                          :docs:
- For more docs on this entire section see [[https://robojackets.github.io/robocup-software/classgameplay_1_1single__robot__composite__behavior_1_1_single_robot_composite_behavior.html][this link.]]
- These subbehaviors show up in the behavior tree when you run your program.
- This can be extremely useful when debugging state transitions or subbehavior assignments.
** Removing Subbehaviors
#+BEGIN_SRC python
self.remove_subbehavior('string name')

self.remove_all_subbehaviors()
#+END_SRC
** Getting Subbehavior Plays
#+BEGIN_SRC python
a_subbheavior = self.subbehavior_with_name('string name')
#+END_SRC
* Real Examples
** CoordinatedPass Tactic
#+BEGIN_SRC python
  def on_enter_running(self):
      receiver = skills.pass_receive.PassReceive()
      receiver.receive_point = self.receive_point
      self.add_subbehavior(receiver,
                           'receiver',
                           required=self.receiver_required)

  def on_exit_running(self):
      self.remove_subbehavior('receiver')
#+END_SRC
** Line Up Tactic
- First State Machine is set up, then:
#+BEGIN_SRC python
  # Triggered whenever the line changes
  self.remove_all_subbehaviors()
  for i in range(6):
      pt = self._line.get_pt(0) + (self.diff * float(i))
      self.add_subbehavior(
          skills.move.Move(pt),
          name="robot" + str(i),
          required=False,
          priority=6 - i)
#+END_SRC

#+BEGIN_SRC python
  def execute_running(self):
      for i in range(6):
          pt = self._line.get_pt(0) + (self.diff * float(i))
          self.subbehavior_with_name("robot" + str(i)).pos = pt
#+END_SRC
* RoboCup Pro Tip
- Find some code doing something like what you want
- Tweak it until it works
- It's less effective than working everything out, but it's great for beginners!

* Assignment
- Create a Triangle Pass Play
- Move 3 Robots into a triangle formation, and pass between them.
- Starter code is in ~soccer/gameplay/plays/skel/triangle_pass.py~ (same as last time).
- Move it to ~soccer/gameplay/plays/testing/triangle_pass.py~ to begin.
** Tips
1. Use Move Skills to move your robots to the triangle initially
2. Use the CoordinatedPass Tactic to pass between, setting receive points as sides of the triangle
3. At a bare minimum, I would make setup and passing states. You may want to have a state for every side of the triangle (or not).
