
#+TITLE: Path Planning
#+AUTHOR: Josh Ting
#+EMAIL: joshting25@gmail.com
#+REVEAL_ROOT: https://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_THEME: black
#+REVEAL_TRANS: linear
#+REVEAL_SPEED: fast
#+REVEAL_PLUGINS: (notes pdf)
#+REVEAL_HLEVEL: 1
#+OPTIONS: toc:nil timestamp:nil reveal_control:t num:nil reveal_history:t tags:nil author:nil

# Export section for md
* Path Planning {#t2016r}                                         :docs:

* Plan for today
- Learn about our path planning system
- Download, compile, and run our RRT repository

* How does path planning fit into our architecture?
[[file:https://docs.google.com/drawings/d/1_l8-LYyQ6hD5gnGM4YBZN7ZSJxnPZsh7NkKnQ0e3aFU/edit]]

* What is Path Planning
- Our robots need to know how to move
- Our path-planning algorithm of choice is the RRT (Rapidly-Exploring Random Tree)



* How the RRT works
1. Start building our tree by placing a root node at the destination
2. Randomly select some coordinate in the position space
3. Identify existing node in the tree that is nearest to that coordinate
4. Add new node in tree branching from nearest node to random coordinate
5. Repeat 2-4 until we find a newe

** Sounds really inefficient
# todo

* Download RRT
- Our rrt repository is located at [[http://github.com/RoboJackets/rrt]]
- On your terminal, type in:
#+BEGIN_SRC shell
git clone http://github.com/RoboJackets/rrt rrt
#+END_SRC
- DO NOT execute this command in your robocup repository

* Compile and run RRT
#+BEGIN_SRC shell
cd rrt
git clone http://github.com/RoboJackets/rrt rrt
make
./build/rrt-viewer
#+END_SRC

* How to use RRT
- Drag start and end points to desired locations
- Drag around the plane space to draw and remove obstacles
- Click run to run until the rrt finds a valid path, or step to execute a single rrt iteration
- Click reset once to delete the tree, twice to delete the previously calculated path

* Tweaking parameters

** Biases
- Increasing Goal Bias

** Adaptive Stepsize Control
- Stepsize now dynamically changes based on whether there are obstacles nearby
- Requires extra computation time to locate nearby obstacles
- Having larger stepsizes when possible reduces total iteration count, which reduces computation time
- Obstacle-light environments benefit the most from this enhancement
